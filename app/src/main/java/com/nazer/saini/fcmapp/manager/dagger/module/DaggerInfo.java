package com.nazer.saini.fcmapp.manager.dagger.module;

public class DaggerInfo {

    /**
     * @Module

    It is applied to classes/abstract classes.
    It supplies/contributes objects to the dagger object graph.
    It can have dependencies on other modules.
    It contains functions annotated with @Provides.
    A Kotlin class annotated with @Module may contain a companion object for static functions. Don’t forget to annotate the companion object with @Module too.
     */

    /**
     * In the above code-block we have declared a computer module, which provides the additional dependencies for creating a computer. We also have @Namedfunction for providing graphics ram as the module provides two different types of graphics ram.
     Also, We declare our power supply provider function in a companion object for direct access.
     This way of declaring static functions using companion objects has a small drawback. An extra class for the companion object will be generated by the dagger.
     @Provides

     It is applied to functions
     It creates/specifies how objects will be provided by the module.
     It should be used to provide complex or external dependencies.
     For further reference let’s call these functions provider functions
     static @Provides

     Everytime to provide a dependency, an instance of our module has to be created. A lot of modules = A lot of instances = A lot more time and performance hit!
     Using static provider functions to provide dependencies, we get better performance, as an instance of module is not required to access this function.
     In Kotlin, we declare functions inside companion object of the class to make them static and annotate the function with @JvmStatic for instance-less access.
     @Component

     It is applied to interfaces
     It specifies all the modules available, and thus also acts as a central provider/factory for dependencies
     */

    /**
     * @Named

    It is a qualifier annotation provided by dagger.
    It is applied to functions.
    It is helpful when we are creating dependencies of the same type, or when our provider functions return same type object.
    Ex. In ComputerModule.kt above, we have two functions which return VideoRam so we annotate one function with @Named("large") which can be requested using the same named annotation as you can see in providesMotherBoardWithLargeVideoRam function arguments.
     */

    /**
     * @Inject

    We can mark fields or constructors with @Inject, so dagger can magically create and inject the field or type.
    When marking a field with @Inject dagger will create an instance of the type of field and initialize our field.
    In Kotlin, the @Inject field has to be public and late initialized with lateinit var.
    Classes/Types with no-arg constructors will be created by dagger, but in case the class/type depends on other class we need to mark our constructor with @Inject, and dagger will figure out the dependencies, and provide the instance of our type wherever required.
     */

    /**
     * @Singleton

    Singleton as the name implies, the instance of dependency remains same for the lifecycle of the application, and everyone who requests the dependency will get the same instance.
    It is used if we want an object to live for the application lifecycle. Ex. some auth helper containing auth token, or networking library instance.
    We shouldn’t have a lot of application singletons, as creating higher number dependency instances might slow our application, as well as the longer the dependency instance lives, the higher memory footprint it puts on our application.
     @Reusable

     It is applied to provider function where we want our dependency instances to be reused between components, but at the same time they should be easily available for garbage collection.
     Or, when you wish to tell dagger that it may create a new instance of dependency, but at the same time, it is allowed to use an already existing one.
     The dependencies with @Reusable annotation live as long as the outer component lives.
     The subcomponents may cache the reusable dependencies from parent components.
     */
}
